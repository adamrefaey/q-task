[project]
name = "async-task-q"
version = "0.9.3"
description = "A modern, async-first, type-safe task queue Python package inspired by Laravel. Native FastAPI integration. Switch between multiple queue backends (Memory, Redis, PostgreSQL, MySQL, RabbitMQ, AWS SQS) with one config line. Automatic, smart ORM serialization using msgpack reduces payloads by 90%+."
readme = "README.md"
requires-python = ">=3.11"
license = { text = "MIT" }
authors = [{ name = "Adam Refaey" }]
keywords = [
    "queue",
    "task",
    "async",
    "laravel",
    "redis",
    "sqs",
    "background-tasks",
    "worker",
]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: 3.14",
    "Framework :: AsyncIO",
    "Topic :: Software Development :: Libraries :: Python Modules",
]

dependencies = ["msgpack>=1.1.0"]

[project.optional-dependencies]
redis = ["redis[hiredis]>=7.1.0"]
sqs = ["aioboto3>=15.5.0", "types-aioboto3[sqs]>=15.5.0"]
postgres = ["asyncpg>=0.30.0", "asyncpg-stubs>=0.30.0"]
mysql = ["asyncmy>=0.2.10"]
rabbitmq = ["aio-pika>=9.5.8"]
sqlite = ["aiosqlite>=0.21.0"]
oracle = ["oracledb>=3.4.1"]
sqlalchemy = ["sqlalchemy>=2.0.44", "greenlet>=3.2.4"]
django = ["django>=5.2.8", "psycopg2-binary>=2.9.11"]
tortoise = ["tortoise-orm>=0.25.1"]
fastapi = ["fastapi>=0.115.0"]
monitor = ["redis[hiredis]>=7.1.0"]  # Required for real-time monitoring UI

all = [
    "async-task-q[redis,sqs,postgres,mysql,rabbitmq,sqlite,oracle,sqlalchemy,django,tortoise,fastapi,monitor]",
]

[project.urls]
Homepage = "https://github.com/adamrefaey/async-task-q"
Repository = "https://github.com/adamrefaey/async-task-q"
Issues = "https://github.com/adamrefaey/async-task-q/issues"


[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[dependency-groups]
dev = [
    "boto3-stubs[essential]>=1.40.76",
    "pyright>=1.1.407",
    "pytest>=9.0.1",
    "pytest-asyncio>=1.3.0",
    "pytest-cov>=7.0.0",
    "ruff>=0.14.6",
    "pre-commit>=4.4.0",
    "pytest-mock>=3.15.1",
    "pytest-timeout>=2.3.1",
    "httpx>=0.28.1",
    "bandit>=1.9.2",
    "pip-audit>=2.9.0",
    "coverage-badge>=1.1.2",
    "yamllint>=1.37.1",
]

[tool.ruff]
line-length = 100
target-version = "py311"

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "F",  # pyflakes
    "I",  # isort
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "UP", # pyupgrade
]
ignore = ["E501"] # line too long (handled by formatter)

[tool.ruff.lint.isort]
known-first-party = ["async_task_q"]
force-sort-within-sections = true

[tool.ruff.lint.mccabe]
max-complexity = 10

[tool.ruff.lint.pylint]
max-args = 8
max-branches = 12
max-returns = 6
max-statements = 50

[tool.pyright]
pythonVersion = "3.11"
typeCheckingMode = "standard"

[tool.pytest.ini_options]
# Use strict mode to avoid false positives from auto-detection
# Strict mode requires explicit @pytest.mark.asyncio decorators on async tests
# This prevents RuntimeWarnings from pytest-asyncio auto-detection interfering with mocks
asyncio_mode = "strict"
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "-s",
    "-v",
    # "--cov=async_task_q",
    # "--cov-branch",
    # "--cov-report=term-missing",
    # "--cov-report=html",
]
markers = [
    "unit: marks tests as unit tests (deselect with '-m \"not unit\"')",
    "integration: marks tests as integration tests (deselect with '-m \"not integration\"')",
]
# Filter warnings from unittest.mock.AsyncMock internals
# These warnings occur because AsyncMock creates coroutines internally that aren't always
# awaited during test collection/teardown. This is a known limitation of unittest.mock
# when used with pytest-asyncio, not an issue with our code.
# Reference: https://github.com/python/cpython/issues/95778
# We use strict mode + explicit @pytest.mark.asyncio decorators (best practice),
# but AsyncMock warnings persist due to mock internals.
filterwarnings = [
    # Filter warnings from unittest.mock.AsyncMock internals
    # These are false positives from AsyncMock's internal coroutine handling
    # when used with pytest-asyncio. This is a known limitation, not a code issue.
    # The warnings can appear from various modules (argparse, importlib, etc.) when
    # AsyncMock coroutines are accessed during test collection or teardown.
    "ignore:coroutine.*was never awaited:RuntimeWarning:unittest.mock",
    "ignore:coroutine.*was never awaited:RuntimeWarning:importlib",
    "ignore:coroutine.*was never awaited:RuntimeWarning:tracemalloc",
    "ignore:coroutine.*was never awaited:RuntimeWarning:re",
    "ignore:coroutine.*was never awaited:RuntimeWarning:argparse",
]

[tool.coverage.run]
source = ["src"]
omit = ["tests/*", "examples/*"]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "\\.\\.\\.",                  # Exclude ellipsis in abstract methods
    "@abstractmethod",
]
